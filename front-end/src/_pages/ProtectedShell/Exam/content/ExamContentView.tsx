import MockExam from "@/components/Exam/ExamView/MockExam";

import React, { useRef } from "react";
import { data_mockExam_algebra_claude } from "./examContentData";

export default function ExamContentView() {
  const downloadableContent = useRef(null);

  return (
    <div ref={downloadableContent}>
      <MockExam questions={mockQuestions} />
    </div>
  );
}

export const mockQuestions: Questions[] = [
  {
    type: "mcq",
    details: {
      question:
        "Which phase pair is traditionally called the compiler's front end?",
      choices: [
        "Intermediate code generator and code optimizer",
        "Scanner (lexical analysis) and parser (syntax analysis)",
        "Code generator and peephole optimizer",
        "Loader and linker",
      ],
      answerIndex: 1,
      mark_allocation: 2,
    },
  },
  {
    type: "mcq",
    details: {
      question:
        "In an LL(1) compiler, FIRST/FOLLOW conflicts most commonly indicate:",
      choices: [
        "Ambiguity in the target machine architecture",
        "That the grammar still contains EBNF metasymbols",
        "Violation of the LL(1) conditions, often due to nullable alternatives",
        "Use of short-circuit Boolean evaluation",
      ],
      answerIndex: 2,
      mark_allocation: 2,
    },
  },
  {
    type: "mcq",
    details: {
      question:
        "On the Parva Virtual Machine (PVM), which register identifies the base of global variables?",
      choices: ["SP", "HP", "GP", "FP"],
      answerIndex: 2,
      mark_allocation: 2,
    },
  },
  {
    type: "mcq",
    details: {
      question: "Which statement about immediate vs direct addressing is TRUE?",
      choices: [
        "Immediate addressing encodes a memory address; direct addressing encodes a literal value.",
        "Direct addressing encodes a memory address; immediate addressing encodes a literal value.",
        "Both encode memory addresses; only the opcode distinguishes them.",
        "Neither puts operands in instruction bytes; both fetch from registers only.",
      ],
      answerIndex: 1,
      mark_allocation: 2,
    },
  },
  {
    type: "mcq",
    details: {
      question:
        "In a recursive descent parser generated by Coco/R, each nonterminal is typically:",
      choices: [
        "Encoded as a bytecode for the PVM",
        "A separate function/method that may call others recursively",
        "A table row in a predictive parser matrix",
        "A DFA state in the scanner",
      ],
      answerIndex: 1,
      mark_allocation: 2,
    },
  },
  {
    type: "mcq",
    details: {
      question:
        "Which component is shared by both front-end and back-end in a traditional compiler architecture?",
      choices: [
        "Error reporter / diagnostics",
        "Intermediate code generator",
        "Peephole optimizer",
        "Loader",
      ],
      answerIndex: 0,
      mark_allocation: 2,
    },
  },

  {
    type: "question",
    details: {
      question:
        "Briefly explain how a recursive descent parser verifies a sentence in an LL(1) grammar. (3–4 sentences)",
      model_answer:
        "It expands a sentential form from the start symbol by calling a method per production; lookahead (one token) guides which production alternative to choose; the calls recurse to match sub-phrases; success consumes tokens to the end with no errors.",
      mark_allocation: 4,
    },
  },
  {
    type: "question",
    details: {
      question:
        "Name four registers or pointers central to the PVM and state what each points to/represents.",
      model_answer:
        "SP (stack pointer), HP (heap pointer), GP (base of globally accessible variables), FP (base of current activation record for locals/parameters).",
      mark_allocation: 4,
    },
  },
  {
    type: "question",
    details: {
      question:
        "Differentiate the L-value and R-value of a designator in assignment, using X = X + 4 as an example.",
      model_answer:
        "Left X denotes an address (L-value: where to store), right X denotes the value fetched from that address (R-value).",
      mark_allocation: 3,
    },
  },
  {
    type: "question",
    details: {
      question:
        "List three key attributes stored in a symbol table entry for an identifier and why each is needed.",
      model_answer:
        "Type (for static checks), Kind (var/const/function restrictions), Offset/location (for code gen addressing).",
      mark_allocation: 3,
    },
  },
  {
    type: "question",
    details: {
      question:
        "Explain why short-circuit (sequential) evaluation is a good fit on a stack machine for && and ||.",
      model_answer:
        "It avoids unnecessary evaluation and maps naturally to conditional jumps/labels that test first operand and jump past second when the result is already determined.",
      mark_allocation: 3,
    },
  },
  {
    type: "question",
    details: {
      question:
        "State one meaningful place to add SYNC and one to add WEAK in a list grammar like Roman numbers and explain the intention.",
      model_answer:
        "Place SYNC before the comma starting the next item to resynchronize at list boundaries; place WEAK before the final '.' to allow a missing period to be tolerated near EOF (limited utility).",
      mark_allocation: 4,
    },
  },

  {
    type: "compoundQuestion",
    details: {
      main_question:
        "Front end vs back end in a single-pass LL(1) compiler for Parva",
      sub_questions: [
        "Name the phases typically considered part of the front end.",
        "Name two synthetic/back-end responsibilities in such a compiler.",
        "Explain in 2–3 sentences why Parva + PVM design simplifies single-pass code generation.",
      ],
      model_answer:
        "Front end: character handler, scanner, parser, static semantic analysis. Back end: intermediate code patterns and final code generation (optionally peephole/optimization). Parva is LL(1) and the PVM opcodes are chosen to map Parva constructs directly, enabling code emission during parsing.",
      mark_allocation: 8,
    },
  },
  {
    type: "compoundQuestion",
    details: {
      main_question: "PVM memory sketch and array store",
      sub_questions: [
        "Draw/describe the PVM memory layout labeling code area, stack (with GP and FP), and heap (HP).",
        "Give PVM instructions to perform List[2] = 10 assuming List is already allocated and bound.",
      ],
      model_answer:
        "Layout: linear memory with code segment; stack managed by SP, frame via FP, globals via GP; heap grows via HP. Code: LDA 0; LDV; LDC 2; LDXA; LDC 10; STO.",
      mark_allocation: 8,
    },
  },
  {
    type: "compoundQuestion",
    details: {
      main_question: "Immediate vs direct addressing",
      sub_questions: [
        "Give a one-line example of immediate addressing and paraphrase its effect.",
        "Give a one-line example of direct addressing and paraphrase its effect.",
        "State one common confusion between these modes.",
      ],
      model_answer:
        "Immediate: MOV AX, 34  → loads literal 34 into AX. Direct: MOV AX, [34] → loads value at memory address 34 into AX. Confusion: thinking both refer to memory addresses or mixing their notations across assemblers.",
      mark_allocation: 6,
    },
  },

  {
    type: "compoundGroupedQuestions",
    details: {
      main_question: "LL(1) compliance workflow on a small list grammar",
      topic: "LL(1) checking steps",
      groupedQuestions: [
        {
          question:
            "First, rewrite the grammar to eliminate EBNF metasymbols and nullable factors explicitly.",
          mark_allocation: 4,
        },
        {
          question:
            "Compute FIRST and FOLLOW for any nullable nonterminals introduced by the rewrite.",
          mark_allocation: 4,
        },
        {
          question:
            "Check LL(1) rules: ensure FIRST/FIRST disjointness and FIRST/FOLLOW for nullable productions; report any violations and where they occur.",
          mark_allocation: 6,
        },
      ],
    },
  },
  {
    type: "compoundGroupedQuestions",
    details: {
      topic: "Coco/R pipeline",
      groupedQuestions: [
        {
          question:
            "State two useful `-options`/features and what they do (e.g., generate FIRST/FOLLOW, test grammar only).",
          mark_allocation: 3,
        },
        {
          question:
            "List the typical generated classes/files and their roles after running Coco/R.",
          mark_allocation: 4,
        },
        {
          question:
            "Give an example host-compiler command (C# or Java) to assemble the generated scanner/parser with the driver.",
          mark_allocation: 3,
        },
      ],
    },
  },

  {
    type: "groupedQuestions",
    details: {
      topic: "Syntax-directed translation on a stack machine",
      groupedQuestions: [
        {
          question:
            "Sketch an AST-driven emission strategy for a while-statement using labels L0/L1/L2 and conditional jumps.",
          mark_allocation: 5,
        },
        {
          question:
            "Explain how attributes (synthesized) can carry types and temporary labels without global variables.",
          mark_allocation: 4,
        },
        {
          question:
            "Show how short-circuit code for `A && B` avoids evaluating B when A is false (pseudo-PVM).",
          mark_allocation: 5,
        },
      ],
    },
  },
  {
    type: "groupedQuestions",
    details: {
      topic: "Symbol table & static checks",
      groupedQuestions: [
        {
          question:
            "List five diagnostics a front end could emit for the sample Parva listing (e.g., number too large, incompatible types, wrong identifier kind).",
          mark_allocation: 5,
        },
        {
          question:
            "For each diagnostic, state which phase detects it (scanner/parser/semantic analyzer).",
          mark_allocation: 5,
        },
        {
          question:
            "Explain how a compatibility check like `Compatible(typeOne, typeTwo)` helps constrain assignments and comparisons.",
          mark_allocation: 4,
        },
      ],
    },
  },

  {
    type: "question",
    details: {
      question:
        "T-diagrams in one paragraph: describe how they model compilers, cross-compilers, and execution pipelines.",
      model_answer:
        "They depict program/translators with input/output languages and host implementation, allowing compositions: a compiler as a program that takes source (left arm) and yields target (right arm), which can then be executed on the target machine or fed to subsequent stages (linker/loader).",
      mark_allocation: 5,
    },
  },
  {
    type: "question",
    details: {
      question:
        "Why are stack machines like the PVM well-suited to evaluating expressions and implementing function calls with locals and recursion? Give two reasons.",
      model_answer:
        "Expression evaluation maps to push/operate sequences; activation records (via FP/GP) and a unified operand stack support locals/params/return discipline cleanly.",
      mark_allocation: 4,
    },
  },
  {
    type: "question",
    details: {
      question:
        "Give a short rationale for single-pass compilation feasibility for Parva.",
      model_answer:
        "Parva is designed to be LL(1) and the PVM instruction set closely matches Parva constructs; code generation can occur during parsing without needing full AST and multi-pass resolution.",
      mark_allocation: 3,
    },
  },
];
